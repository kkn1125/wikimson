import {tables} from '../../../store/tables/deadlock.js';

export default {
    published: true,
    title: 'dead lock',
    modified: '',
    done: false,
    tags: ['os', 'classical', 'problem', 'synchronization'],
    categories: ['cs','Operating System'],
    authors: ['kimson'],
    wrote: '2022-03-07 15:52:57',
    toc: true,
    md: true,
    content: [`
# 교착상태 (deadlock)

## 교착상태 처리

> 아래의 *4가지 조건을 깨는 것을 고려*해야 교착상태를 해결할 수 있다.

- 교착상태 *방지* ==> Deadlock Prvention
- 교착상태 *회피* ==> Deadlock Avoidance
- 교착상태 *검출* 및 *복구* ==> Deadlock Detection & Recovery
- 교착상태 *무시* ==> Don't care

### 교착상태 방지

*deadlock prevention*이라 하며, 교착상태 4가지 필요조건 중 한 가지 이상 불만족하도록 하는 것을 말한다. 즉, 4가지 조건이 만족될 경우 교착상태가 *발생 할 수* 있기 때문에 *한 가지 이상 불만족* 시키면 교착상태를 피할 수 있다는 것이다.

#### 상호배타 (Mutual exclustion) {:.text-danger}

3개의 프로세스가 2개의 자원을 공유한다 가정하면 두 개의 프로세스가 두 개의 자원을 사용 중 일 때, 하나의 프로세스는 대기해야 한다. 그러므로 자원을 공유 가능하게 하려면 원천적 불가한 경우가 많다. CPU, 메모리, 프린터 등도 마찬가지이다. 이 방법은 교착상태 해결에 부적잡하다.

#### 보유 및 대기 (Hold and wait)

자원을 가지고 있으면서 다른 자원을 기다리지 않고, 식사하는 철학자를 예로 젓가락 하나를 잡고 있으면서 다른 젓가락을 잡는 것이 아닌 동시에 두 개를 잡도록하는 것이다.

둘 중 하나라도 잡히지 않는다면 잡지 않는(hold하지 않는) 것이다. 또는 하나의 젓가락을 잡은 상태에서 다른 젓가락을 잡으려 할 때 이미 사용 중이라면 잡았던 젓가락을 놓아버리는 것이다.

하지만 단점으로는 기아(starvation)가 발생 할 수 있다. 하나의 젓가락을 잡고 있을 때 다른 젓가락이 사용 중이면 놓아버리기 때문에 둘 다 잡을 확률이 그만큼 떨어지는 것이고, 굶을 수 있기 때문이다. 즉, 프로세스가 진행을 못 할 확률이 높아지는 것이다. 나아가 자원의 활용률 또한 저하가 된다. 이 방법은 일부 가능하다.

#### 비선점 (No preemption)

여러 프로세스가 돌고 있을 때 해당 자원을 \`P@3@\`이 들고 있다면 놓아주지 않아도 강제로 빼앗을 수 있게 하는 것이다. 프린터를 예로 들면 실제로 불가능하다. 누군가 프린터를 사용하는 중에 다른 사용자가 뺏어온다면 프린터를 엉망이 될 것이다. \`CPU\`는 일부 가능하겠지만 뺏어오는 것은 불가능하다.

#### 환형대기 (Circular wait)

자원에 번호를 부여하고, 번호를 오름차순으로 자원을 요청하면 된다. 일반적으로 가능한 이야기이다. 철학자 문제를 예로 보자면 아래의 그림을 참고해보자.

${wikiFilter.img('os/phil02.jpg', 'kimson', 'sample')}

이전 포스팅에 있던 그림에서 번호만 매겨보았다. \`P@0@\`부터 \`P@3@\`까지는 동일하게 왼쪽, 오른쪽 순으로 젓가락을 든다. 하지만 마지막 \`P@4@\`는 오름차순이기 때문에 \`R@0@\`을 먼저, \`R@4@\`를 그 다음으로 든다. 즉, 반대로 들면서 환형이 깨지기 때문에 교착상태가 발생하지 않는 것이다.

하지만 철학자의 문제를 봤을 때의 이야기이고, 컴퓨터에 존재하는 *모든 자원에 입각*해서 보면 *일반적으로 자원의 활용률*은 떨어진다. 그래서 이 또한 좋은 방법은 아니다.

> 이 중에서 현실적인 방법으로는 Hold & wait나 Circular wait를 깨는 방법이 되겠다.

### 교착상태 회피

*dealock avoidance*라 하며, 교착상태를 다르게 해석해보는 것이다. 교착상태 회피에서 바라보는 교착상태는 자원을 잘못 할당 해서, 즉, 프로세스들이 자원을 요청할 때 잘못된 응답을 했기 때문에 일어난 것으로 보는 것이다.

#### 예제 1

12개의 \`magnetic tape\` 및 3개의 \`process\`가 있다고 가정하자. 이 때 안전하게 할당하는 것을 생각해보자.

${tables['ex01']}

12개의 테이프에서 \`P@0@\`에 현재 필요로 하는 5개를 충분히 줄 수 있다. 나머지 \`P@1@\`과 \`P@2@\`에게 모두 나누어 줘도 3개의 테이프가 남게 된다.

지금까지 보면 안전하게 할당하는 것처럼 보인다. 실제로 안전한지 확인해보자.

\`P@0@\`은 최대로 필요한 개수가 10개이다. 현재 필요한 것을 모든 프로세스에 충족시켜 주면, \`P@0@\`는 그 다음 필요한 5개를 요청 할 때 테이프가 부족하므로 할당하지 못하게 된다. \`P@1@\`은 2개를 더 필요로 하기 때문에 할당이 된다. 그러면 최대 4개를 필요로 했기 때문에 \`P@1@\`은 실행을 끝낼 수 있다.

끝내고 나면 OS에 자원을 반환한다. 그러면 \`P@2@\`는 7개가 필요하므로 넘어가고, \`P@0@\`는 5개를 필요로 하기 때문에 자원을 받아 돌 수 있게 된다.

\`P@0@\`는 실행을 끝내고 10개를 반환하고, 마지막으로 \`P@2@\`에 7개를 할당하고 \`P@2@\`도 실행 완료 후 자원을 모두 반환한다.

문제를 조금 바꾸어 보자.

${tables['ex02']}

문제에서 \`P@2@\`가 현재 필요로하는 자원의 개수를 1 늘렸다.

이때 첫 번째 케이스처럼 모두 할당하고 시작한다면, \`P@0@\`은 5개를 더 필요로 하는데 테이프는 2개만 남아 있어서 할당하지 못한다. \`P@1@\`은 2개를 더 필요로 하기 때문에 할당 가능하고 \`P@1@\`은 실행되어 나중에 종료하면서 자원을 4개 반환한다.

하지만 \`P@0@\`는 5개 \`P@2@\`는 6개를 더 필요로 하는데 남느 자원이 4개 밖에 없는 상황이 온다.

이러한 것을 *불안전한 할당(Unsafe allocation)*이라 한다.

... 작성 중 ...
`],
    ref: [
        {
            name: '경성대 양희재 교수님 - 4강 교착상태',
            link: 'http://www.kocw.net/home/cview.do?mty=p&kemId=978503',
        },
    ],
    template(){
        this.title = this.origin.name;
        return `
        ${wikiFilter.all.call(this)}
        `
    }
}