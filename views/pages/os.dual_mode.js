export default {
    published: true,
    title: '이중 모드',
    modified: '2022-02-23 21:39:54',
    done: true,
    tags: ['os', 'dual mode', '이중 모드'],
    categories: ['cs','Operating System'],
    authors: ['kimson'],
    wrote: '2022-02-23 17:39:58',
    toc: true,
    md: true,
    content: [
`
### 이중 모드 (Dual Mode)

*한 컴퓨터*를 *여러 사람*이 동시에 *사용*한다. 예를 들어 수강신청을 할 때 하나의 서버 컴퓨터를 여러 사람이 사용할 때이다. 스마트 폰이나 PC로 여러 프로그램을 사용하는 것도 마찬가지의 형태이다.

이렇게 여러 사람이 컴퓨터를 사용 할 때 *한 사람에 의해 여러 사람에게 영향을 미칠 수 있는 경우*가 있다. 사용자가 많으면 많을수록 치명적이다.

###### 고의/실수로 인한 전체 영향

프로그램 전반에 영향을 미치는 명령어 들이 있는데 아래와 같은 류의 명령이다.

1. Stop
2. Halt
3. Reset
4. 등등 ...

이러한 *명령을 아무나* 내릴 수 있다면 *치명적인 결과를 초래*하기 때문에 *관리자만 사용*하도록 하고 *사용자는 사용 못 하도록* 하는 것이 \`이중 모드\`이다.

이중 모드는 CPU가 동작하는 모드를 두 가지를 두겠다는 것이다.

1. \`관리자 모드{:.bg-danger}\` ==> \`CPU\`가 메인 메모리의 명령을 읽어 와서 *OS의 명령을 실행 할 때*는 *관리자 모드*로 동작한다.
    - ?== Supervisor Mode(슈퍼바이저 모드)
    - ?== System Mode(시스템 모드)
    - ?== Monitor Mode(감시자 모드)
    - ?== Privileged Mode(특권 모드)
2. \`사용자 모드{:.bg-danger}\` ==> \`CPU\`가 메인 메모리 중 일반 유저 메모리 영역의 내용을 읽어와 실행 할 때는 *사용자 모드*로 동작한다.
    - User Mode(사용자 모드)

###### 특권 명령(Privileged Instruction)

유저 모드에서 내릴 수 없는 관리자 모드에서만 가능 한 명령어이다. 대표적으로 \`STOP\`, \`HALT\`, \`RESET\`이 있는데 그 외에 아래와 같은 명령어들이 있다.

- SET_TIMER
- SET_HW
- 등등 ...

일반 유저가 시간을 마음대로 바꿀 수 있다고 가정한다면 다른 누군가는 피해를 입을 수 있다. 이러한 류의 명령을 특권 명령으로 해서 아무나 접근 못하는 명령으로 만들 필요가 있다.

하드웨어의 값을 바꾸는 것 또한 일반 유저가 내리는 것은 위험하므로 특권 명령 지정으로 관리자 모드로 제한하여 모드를 두 가지 둔 다는 것이 핵심이다.

### 이중 모드는 어떻게 만드나?

CPU에 \`Register\`와 ${wikiFilter.toRef('cs-cu','정의-1','Control Unit')}, ${wikiFilter.toRef('cs-alu','정의-1','ALU')}가 있다. \`Register\`는 비트들의 모음이다. 예를 들어 \`32bit\`면 32개의 \`bit\`가 있다는 것이고, *프로세스(CPU)의 상태*를 나타내는 \`bit\`를 둘 수 있다.

###### Flag (깃발)

- \`Carry\` ==> 한 자리 올라 갔을 때
- \`Nagative\` ==> 연산의 결과가 음수 일 때
- \`Zero\` ==> 연산의 결과가 0이 나왔을 때
- \`Overflow\` ==> 연산 결과가 자리 범위를 넘어섰을 떄

어떠한 이벤트가 발생하면 그에 해당하는 것을 나타낸다. 이중모드를 만들 때는 하나의 \`Flag\`를 더 추가하게 되는데 \`bit\`를 하나 더 추가하여 만들게 된다.

*Monitor Bit*라는 명칭으로 추가 한다고 가정하자. 1이면 관리자 모드, 0이면 사용자 모드로 이중 모드를 표현하게 된다.

###### 이중 모드 과정

컴퓨터 전원을 키면 부팅이 일어난다. 하드디스크의 OS가 메인 메모리로 올라간다. *올라가는 도중에 Monitor Mode가 1*로 되어 *시스템 모드*에서 동작한다. 즉, 모든 명령을 다 내릴 수 있는 상태이다.

\`OS 서비스\`가 끝나고나면 사용자 프로그램을 올릴 수 있는 상태가 된다. \`게임\`을 올린다고 가정했을 때 메인 메모리로 \`게임\`이 올라간다. \`CPU\`는 \`게임\`을 실행하게 되는데 그 전에, *OS 서비스에서 CPU로 갈 때* *OS가 \`Monitor Mode\`의 비트를 0으로 바꾸어* 유저 모드로 변경해준다.

게임을 실행 할 때 클릭은 사용자가 하지만 메인 메모리에 올려주는 역할은 실제로 OS가 한다. 그렇게 OS가 올려놓은 게임을 CPU가 실행하기 직전에 OS가 \`Monitor Mode Bit\`를 \`1 -> 0\`으로 바꾸어 준다는 이야기이다.

###### 하드디스크 접근

이어서 이야기하면, 게임을 하다가 스코어를 저장한다고 가정할 때, 하드디스크에 게임 프로그램이 직접적으로 저장하는 것이 아닌 OS가 대신해준다.

만일 게임 프로그램에서 하드디스크에 접근하고 저장하게 되면 일반 유저 프로그램이 하드디스크에 접근 가능하다는 것이고, 하드디스크 안에 있는 남의 파일도 접근할 수 있다는 이야기가 된다.

그래서 유저 프로그램에서 직접 하드디스크에 접근하는 방법은 좋은 접근법이 아닐뿐더러 보안상 좋지 못하다.

그래서 유저 프로그램은 하드디스크에 접근할 때 OS에 부탁을 하게 된다. 이 때 사용하는 *부탁*은 *Software Interrupt*이다.

😀 \`"이 게임의 스코어를 하드디스크에 저장하고 싶어"\`

Interrupt가 걸리게 되면 *Monitor Mode Bit는 1이 되고* 모든 명령이 가능한 상태가 되며, CPU는 하던 일을 중단하고 *OS안에* 들어있는 *${wikiFilter.toRef('cs-isr','정의-1','Interrupt Service Routine(ISR)')}으로 Jump*한다.

서비스 루틴에서 프로그램이 저장하기를 원한다는 것을 알고 OS의 코드가 동작해서 유저 프로그램을 대신해서 하드디스크에 저장해주게 된다.

저장이 끝나면 다시 유저 프로그램으로 *돌아오기 전 Monitor Mode Bit를 0*으로 다시 바꾸어주고 복귀하게 된다.

> *Interrupt Service Routine이 동작* 할 때는 *시스템 모드에서 동작*하게 된다.

###### 사용자가 특권 명령을 내리면?

만일 사용자가 \`STOP\`과 같은 명령을 내린다면 *CPU는 Monitor Bit를 확인*하고, 0인데 STOP명령이 들어오면 *내부적으로 인터럽트*가 걸린 것으로 판단한다. 

*CPU는 명령을 실행하는 대신*에 OS안에 있는 *잘 못 된 요청을 했을 때 동작하는 ISR로 Jump*해서 해당 프로그램을 *강제 종료*하도록 한다. 즉, 메모리에서 없어지도록 한다는 것이다.

### 하드웨어 보호

이중모드는 이러한 측면에서 보호와 밀접한 관련이 있다. 컴퓨터에서 보호받아야 되는 것이 3가지 있다.

1. 입출력장치 보호
2. 메모리 보호
3. CPU 보호

###### 입출력 장치 보호

서버 컴퓨터를 경유해서 프린터를 여러 사람이 사용한다고 가정해보자.

${wikiFilter.img('os/os-dual01.jpg', 'kimson', 'sample')}

이때 \`A\`라는 사람이 출력하고, \`B\`라는 사람이 Reset하고, \`C\`라는 사람이 출력한다면 프린터에 \`A\`사람 내용 한 줄, \`C\`사람 한 줄, 리셋 등 혼선이 생길 수 있다.

이런 상태라면 다른 사람의 컴퓨터 중요 파일을 아무나 접근할 수 도 있다. 이렇게 되면 안되기 때문에 입출력 장치에 대한 보호가 필요하다.

###### 해결방법

과정을 보면, 소프트웨어 인터럽트를 걸어 CPU가 중지하고, OS의 ISR로 Jump하고 OS가 대신해서 프린터를 가동시키고 유저로 돌아가게 한다.

일반 유저가 프린터나 디스크에 접근 못하도록 하려면 입출력 장치를 제어하는 명령어인 \`In(입력장치)\`, \`Out(출력장치)\`을 아무나 못 내리도록 시스템(OS)만 내릴수 있도록 특권 명령으로 만든다.

유저 모드에서 사용자가 \`In\`이나 \`Out\`등 특권 명령을 내리면 위에서 언급했던 ${wikiFilter.sup('사용자가 특권 명령을 내리면?-7', '권한 없는 명령')}과정처럼 해당 프로그램을 강제 종료시킨다.

OS안에는 여러 사용자가 있을 때 A라는 사용자가 B라는 사용자의 파일을 하드디스크에서 읽기 요청할 때 권한이 있는지를 판별하는 코드가 심어져 있어 해당 사용자가 아니면 거부하는 기능을 가진다.

###### Privileged Instruction Violation

이렇게 특권 명령 권한을 벗어나 프로그램을 강제종료 시키는 일련의 과정을 *Privileged Instruction Violation(특권 명령 위반)*이라 한다.

### 메모리 보호

컴퓨터 전원을 키면 메모리에는 항상 OS가 상주하게 된다. 사용자 프로그램이 여러 개 올라와 있을 수 도 있다.

그렇다면 유저 프로그램이 실행되면서 ISR코드를 바꿀 수도 있지 않을까? 다른 유저 프로그램을 본다던지 OS 코드를 본다던지 등의 일이 발생할 수 있다. 이러한 것을 해킹이라 한다.

CPU에서 메인메모리로 Address Bus(주소 다발)가 간다. 몇 번지를 읽겠다 하면 그 주소에 해당하는 내용이 Data Bus를 타고 CPU로 간다.

일반 유저 프로그램이 다른 영역에 못 들어가게 하려면 Address Bus를 잘라버리면 된다. 하지만 이것은 본인의 영역 또한 들어가지 못하므로 좋은 해결방법이 아니다.

###### Memory Management Unit (MMU){:.text-danger}

Address Bus 중간에 하나의 역할을 하는 기능을 둔다. \`유저 A\` 영역이 500 ~ 1000번지라 가정할 때 \`유저 A\`가 500 ~ 1000 사이의 번지를 요청하면 통과시키고, 그 외의 번지를 차단하는 것이다. 이것이 바로 *메모리 관리 장치 (MMU)*이다

\`유저 B\`, \`유저 C\` 등도 마찬가지다.

###### MMU는 어떻게 만들어질까?

\`MMU\` 안에 Register를 둔다. OS가 MMU의 Base, Limit라는 속성을 주고 Base와 Limit사이를 통과시키도록 하는 것이다. *자신의 범위를 넘어서는 요청*이 있다면 *CPU에 인터럽트*를 걸어 *OS의 ISR로 점프*하도록 한다.

그렇게 되면 입출력 보호때와 마찬가지로 *해당 프로그램을 종료*시킨다.

> \`MMU\`의 \`Base\`, \`Limit\`의 값을 *변경*하는 것도 *특권 명령의 영역*이다.

###### Segment Violation

위와 같은 *다른 사용자* 또는 *운영체제 영역 메모리 접근 시도*를 *Segment Violation (영역 침범)*이라 한다.

### CPU 보호

C언어로 프로그램을 짠다고 가정하자. JavaScript등 뭐든 상관업다.

예를 들어 아래와 같은 코드가 있다고 할 때.

\`\`\`javascript
while ( n = 1 ) {
    /* ... */
}
\`\`\`

이는 금방 알 수 있듯이 무한루프를 돌게 된다. 만일 \`유저 A\`라는 프로그램이 끝나지 않는 무한루프를 돈다면, CPU는 계속 \`유저 A\`에서 벗어나지 못하게 된다.

이를 해결하기 위해 \`Timer\`를 두게 된다.

###### Timer

일정 시간 주기로 \`CPU\`에게 \`Interrupt\`를 걸도록 한다. 예제처럼 무한 루프에 빠져있다 하더라도 *무조건 중단*하고 *OS의 ISR로 Jump*한다.

ISR에서 *다른 프로세스에 골고루 시간 배분*이 되고 있는지, *체크*하게 한다.

시간이 지나도 특정 프로세스가 *계속해서 작업을 진행 중*이라면(묶여있다면) *강제로 다음 프로그램으로 넘어가도록 OS가 조정*을 해준다.

ISR을 이런 식으로 짜서 *하나의 프로그램*에 *정체되어 있지 않도록* 하는 것을 *CPU보호*라한다.
`,
    ],
    ref: [
        // {
        //     name: '',//'생활코딩 디자인 패턴',
        //     link: '',//'https://opentutorials.org/module/327/3828'
        // },
    ],
    template(){
        this.title = this.origin.name;
        return `
        ${wikiFilter.all.call(this)}
        `
    }
}

// th: 핵심|설명@
// tb: !Model|데이터를 가지고 로직을 처리한다. 데이터베이스와 대응 될 수 있다\\
// !View|요청된 페이지를 데이터 처리의 과정을 거쳐 브라우저에 나타낼 요소들을 출력해주는 역할을 한다.\\
// !Controller|사용자의 요청을 받아 요청에 맞는 Model의 로직을 실행하고 데이터의 흐름을 제어한다.@
// :end